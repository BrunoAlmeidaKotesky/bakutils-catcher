function l(t){return!!t&&t instanceof Promise}function p(t){return!!t&&typeof t=="object"&&typeof t.then=="function"}function y(t){return p(t)&&typeof t.catch=="function"}function A(t){return typeof t=="function"||t instanceof Function}function w(t){return t&&typeof t.errorCode=="number"&&typeof t.message=="string"}const s=t=>typeof t=="function"?t():t;function m(t,n,o){return function(...e){const i=r=>n.call(null,r,this,...e);try{const r=o.apply(this,e);return l(r)?r.catch(i):y(r)?new Promise((h,k)=>r.then(h).catch(k)).catch(i):p(r)?Promise.resolve(r).catch(i):r}catch(r){if(!t||r instanceof t||w(r))return i(r);throw r}}}function O(t,n){return(o,e,i)=>{const r=i.value;return i.value=m(t,n,r),i}}const d=(t,n)=>O(t,n),N=t=>d(Error,t),P=t=>O(void 0,t);function M(t,n){return m(Error,n,t)}function U(t,n,o){return m(n,o,t)}function u(t){return{type:"ok",value:t,unwrap:()=>t,unwrapOr:()=>t,unwrapOrElse:()=>t,isErr:()=>!1,isOk:()=>!0,toOption:()=>a(t),flatMap:n=>n(t),match:n=>n.Ok(t),map:n=>{try{return u(n(t))}catch(o){return f(o)}},flatMapAsync:async n=>n(t)}}function f(t){return{type:"error",error:t,unwrap:()=>{throw t},unwrapOr:n=>n,unwrapOrElse:n=>n(t),isErr:()=>!0,isOk:()=>!1,toOption:()=>c,toJSON:()=>{throw t},flatMap:()=>f(t),match:n=>n.Err(t),map:n=>this,flatMapAsync:async()=>f(t)}}function _(t){return t&&(t.type==="ok"&&"value"in t||t.type==="error"&&"error"in t)}function S(t){return t==null?!1:typeof t=="object"&&!!t&&"type"in t&&t.type==="some"||t.type==="none"}function E(t){if(t==null)throw new Error("Some() cannot be called with null or undefined");return{type:"some",value:t,unwrap:()=>t,unwrapOrU:()=>t,unwrapOr:()=>t,isSome:()=>!0,isNone:()=>!1,map(n){return a(()=>n(t))},flatMap:n=>n(t),flatMapAsync:async n=>n(t),okOr:n=>u(t),mapOr:(n,o)=>{const e=a(n(t));return e.isNone()?a(s(o)):e},flatten:()=>{if(S(t)&&t.isSome())return t;throw new Error("Cannot flatten a non-option value")},match:n=>n.Some(t),toJSON:()=>t,clone:()=>structuredClone(this),toString:()=>t.toString?t.toString():`Some(${t})`}}const c={type:"none",unwrap:()=>{throw new Error("Cannot unwrap None")},unwrapOr:t=>s(t),unwrapOrU:()=>{},isSome:()=>!1,isNone:()=>!0,map:()=>c,flatMap:t=>c,flatMapAsync:async t=>c,okOr:t=>f(s(t)),mapOr:(t,n)=>a(s(n)),toJSON:()=>null,flatten:()=>c,match:t=>t.None(),clone:()=>c,toString:()=>"none"};Object.freeze(c);function a(t){try{const n=s(t);return n==null?c:E(n)}catch(n){return console.error(n),c}}class b{constructor(n,o){Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.type=n,this.value=o}match(n){return n[this.type](this.value)}is(n){return this.type===n}}function B(t,n){return new b(t,n)}async function K(t,n,o){try{const e=t(...n??[]);if(l(e)){const i=await e;return u(i)}if(y(e)){const i=await new Promise((r,h)=>e.then(r).catch(h));return u(i)}if(p(e)){const i=await Promise.resolve(e);return u(i)}return u(e)}catch(e){const i=typeof o=="function"?o(e,...n??[]):o??e;return f(i)}}export{P as AnyErrorCatcher,s as BAKUtilsGetFnValue,A as BAKUtilsIsFunction,l as BAKUtilsIsPromise,p as BAKUtilsIsThenable,w as BAKUtilsIsXrmError,y as BAKUtilsIsXrmPromiseLike,d as Catcher,N as DefaultCatcher,f as Err,c as None,u as Ok,b as OneOfVariant,a as Option,K as ResultTry,E as Some,U as catcher,B as createOneOf,M as defaultCatcher,S as isOption,_ as isResult};
