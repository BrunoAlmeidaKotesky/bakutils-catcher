function O(n){return n&&n instanceof Promise}function p(n){return typeof n=="function"||n instanceof Function}const u=n=>typeof n=="function"?n():n;function w(n,t){return(e,o,r)=>{const{value:a}=r;return r.value=function(...h){try{const c=a.apply(this,h);return O(c)?c.catch(y=>{if(p(t)&&(n===void 0||y instanceof n))return t.call(null,y,this,...h);throw y}):c}catch(c){if(p(t)&&(n===void 0||c instanceof n))return t.call(null,c,this,...h);throw c}},r}}function m(n,t,e){return function(...o){try{const r=n(...o);return O(r)?r.catch(a=>{if(p(e)&&(t===void 0||a instanceof t))return e.call(null,a,this,...o);throw a}):r}catch(r){if(p(e)&&(t===void 0||r instanceof t))return e.call(null,r,this,...o);throw r}}}function k(n,t){return m(n,Error,t)}function N(n,t){return w(n,t)}function A(n){return w(Error,n)}function l(n){return{type:"ok",value:n,unwrap:()=>n,unwrapOr:()=>n,unwrapOrElse:()=>n,isErr:()=>!1,isOk:()=>!0,toOption:()=>f(n),flatMap:t=>t(n),match:t=>t.Ok(n),map:t=>{try{return l(t(n))}catch(e){return s(e)}},flatMapAsync:async t=>t(n)}}function s(n){return{type:"error",error:n,unwrap:()=>{throw n},unwrapOr:t=>t,unwrapOrElse:t=>t(n),isErr:()=>!0,isOk:()=>!1,toOption:()=>i,toJSON:()=>{throw n},flatMap:()=>s(n),match:t=>t.Err(n),map:t=>this,flatMapAsync:async()=>s(n)}}function M(n){return n&&(n.type==="ok"&&"value"in n||n.type==="error"&&"error"in n)}function d(n){return n==null?!1:typeof n=="object"&&!!n&&"type"in n&&n.type==="some"||n.type==="none"}function S(n){if(n==null)throw new Error("Some() cannot be called with null or undefined");return{type:"some",value:n,unwrap:()=>n,unwrapOrU:()=>n,unwrapOr:()=>n,isSome:()=>!0,isNone:()=>!1,map(t){return f(()=>t(n))},flatMap:t=>t(n),flatMapAsync:async t=>t(n),okOr:t=>l(n),mapOr:(t,e)=>{const o=f(t(n));return o.isNone()?f(u(e)):o},flatten:()=>{if(d(n)&&n.isSome())return n;throw new Error("Cannot flatten a non-option value")},match:t=>t.Some(n),toJSON:()=>n,clone:()=>structuredClone(this),toString:()=>n.toString?n.toString():`Some(${n})`}}const i={type:"none",unwrap:()=>{throw new Error("Cannot unwrap None")},unwrapOr:n=>u(n),unwrapOrU:()=>{},isSome:()=>!1,isNone:()=>!0,map:()=>i,flatMap:n=>i,flatMapAsync:async n=>i,okOr:n=>s(u(n)),mapOr:(n,t)=>f(u(t)),toJSON:()=>null,flatten:()=>i,match:n=>n.None(),clone:()=>i,toString:()=>"none"};Object.freeze(i);function f(n){try{const t=u(n);return t==null?i:S(t)}catch(t){return console.error(t),i}}class b{constructor(t,e){Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.type=t,this.value=e}match(t){return t[this.type](this.value)}is(t){return this.type===t}}function _(n,t){return new b(n,t)}export{u as BAKUtilsGetFnValue,p as BAKUtilsIsFunction,O as BAKUtilsIsPromise,N as Catcher,A as DefaultCatcher,s as Err,i as None,l as Ok,b as OneOfVariant,f as Option,S as Some,m as catcher,_ as createOneOf,k as defaultCatcher,d as isOption,M as isResult};
